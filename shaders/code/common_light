#include "code/f16x2"
#include "code/u8x4"

void sort(inout float4 depths, inout uint4 indices)
{
	if (depths.x > depths.y)
	{
		indices = indices.yxzw;
		depths = depths.yxzw;
	}
}

float3 inner_light(float2 uv, float depth, float3 normal, float3 colour)
{
	float z_neg = -z_near / (1 - depth);
	float4 surface_pos = float4( uv_to_ray(uv) * z_neg, z_neg, 1.0 );
	float4 reprojected = mul(viewI_light_view_proj, surface_pos);

	float3 lightvec = light_pos - surface_pos.xyz;
	float l = length(lightvec);
	float fade = smoothstep(radius, radius * 0.9, l);
	if (fade == 0.0) return 0;//discard;

	float lighted = SHADOW_TEST;

	if (lighted == 0.0) return 0;//discard;

    float radiance = lighted * fade *
		max(0.0, dot( lightvec, normal )) / (l * l * l) * light_scale;

	return radiance * colour * light_colour;
}

float4 common_light(PPosition input)
{
	float2 uv = input.svposition.xy * rcpres;

	float depth = zbuffer.Sample(sm_point, uv).x;
	float3 normal = gbuffer0.Sample(sm_point, uv).xyz;
	float3 colour = gbuffer1.Sample(sm_point, uv).xyz; //! easy perf
	float3 result = inner_light(uv, depth, normal, colour);

	return float4(result, 1.0);
}

float4 common_light_oit(PPosition input)
{
	float2 uv = input.svposition.xy * rcpres;

	float3 normal;
	float3 colour;
	float3 result = 0;
	float depth = zbuffer.Sample(sm_point, uv).x;

	uint start = 4 * (input.svposition.y * res.x + input.svposition.x);
	uint index = start_buffer.Load(start);
	if (index == -1) return float4(result, 1.0);

	float4 depths = 1;
	OITFragment fragments[4];

	[unroll]
	for (uint i = 0; i < 4 && index != -1; i++)
	{
		fragments[i] = fragment_buffer[index];
		uint packed = fragments[i].normal_z_and_depth;
		depths[i] = f16tof32(packed >> 16);
		index = fragment_buffer[index].next;
	}

	uint4 indices = uint4(0, 1, 2, 3);
	sort(depths, indices);

	[unroll]
	for (uint j = 0; j < i; j++)
	{
		if (depths[j] > depth) break;
		OITFragment fragment = fragments[indices[j]];
		normal.xy = f16x2_unpack(fragment.normal_xy);
		normal.z = f16tof32(fragment.normal_z_and_depth & 0x0000ffff);
		colour = u8x4_unpack(fragment.colour_rgba).xyz;
		result += inner_light(uv, depths[j], normal, colour);
	}

	//return z_near / (1 - depths) * 0.1;//
	return float4(result, 1.0);
}